{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState } from 'react';\n\n// Validation utility functions and rules\nexport const ValidationRules = {\n  // Name validation\n  name: {\n    required: true,\n    minLength: 2,\n    maxLength: 50,\n    pattern: /^[a-zA-Z\\s'-]+$/,\n    message: {\n      required: 'Name is required',\n      minLength: 'Name must be at least 2 characters',\n      maxLength: 'Name cannot exceed 50 characters',\n      pattern: 'Name can only contain letters, spaces, hyphens, and apostrophes'\n    }\n  },\n  // Email validation\n  email: {\n    required: true,\n    pattern: /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/,\n    maxLength: 320,\n    message: {\n      required: 'Email is required',\n      pattern: 'Please enter a valid email address',\n      maxLength: 'Email cannot exceed 320 characters'\n    }\n  },\n  // Phone validation (Malaysian format)\n  phone: {\n    required: false,\n    pattern: /^(\\+?6?01)[0-46-9]-*[0-9]{7,8}$/,\n    message: {\n      pattern: 'Please enter a valid Malaysian phone number (e.g., +60123456789)'\n    }\n  },\n  // Password validation\n  password: {\n    required: true,\n    minLength: 8,\n    maxLength: 128,\n    patterns: {\n      lowercase: /[a-z]/,\n      uppercase: /[A-Z]/,\n      number: /[0-9]/,\n      special: /[!@#$%^&*(),.?\":{}|<>]/\n    },\n    message: {\n      required: 'Password is required',\n      minLength: 'Password must be at least 8 characters',\n      maxLength: 'Password cannot exceed 128 characters',\n      lowercase: 'Password must contain at least one lowercase letter',\n      uppercase: 'Password must contain at least one uppercase letter',\n      number: 'Password must contain at least one number',\n      special: 'Password must contain at least one special character'\n    }\n  },\n  // Location validation\n  location: {\n    required: true,\n    message: {\n      required: 'Please select a location',\n      different: 'Origin and destination must be different'\n    }\n  },\n  // Date validation\n  date: {\n    required: true,\n    futureOnly: true,\n    message: {\n      required: 'Date is required',\n      futureOnly: 'Date must be in the future',\n      invalid: 'Please enter a valid date'\n    }\n  },\n  // Price validation\n  price: {\n    required: true,\n    min: 0,\n    max: 9999.99,\n    decimal: 2,\n    message: {\n      required: 'Price is required',\n      min: 'Price cannot be negative',\n      max: 'Price cannot exceed RM 9,999.99',\n      number: 'Price must be a valid number'\n    }\n  },\n  // Coordinates validation\n  latitude: {\n    required: false,\n    min: -90,\n    max: 90,\n    message: {\n      min: 'Latitude must be between -90 and 90',\n      max: 'Latitude must be between -90 and 90',\n      number: 'Latitude must be a valid number'\n    }\n  },\n  longitude: {\n    required: false,\n    min: -180,\n    max: 180,\n    message: {\n      min: 'Longitude must be between -180 and 180',\n      max: 'Longitude must be between -180 and 180',\n      number: 'Longitude must be a valid number'\n    }\n  },\n  // Passenger count validation\n  passengers: {\n    required: true,\n    min: 1,\n    max: 8,\n    integer: true,\n    message: {\n      required: 'Number of passengers is required',\n      min: 'At least 1 passenger is required',\n      max: 'Maximum 8 passengers allowed',\n      integer: 'Number of passengers must be a whole number'\n    }\n  },\n  // Card number validation\n  cardNumber: {\n    required: true,\n    pattern: /^[0-9]{13,19}$/,\n    message: {\n      required: 'Card number is required',\n      pattern: 'Please enter a valid card number (13-19 digits)'\n    }\n  },\n  // CVV validation\n  cvv: {\n    required: true,\n    pattern: /^[0-9]{3,4}$/,\n    message: {\n      required: 'CVV is required',\n      pattern: 'CVV must be 3 or 4 digits'\n    }\n  },\n  // Expiry date validation\n  expiryDate: {\n    required: true,\n    pattern: /^(0[1-9]|1[0-2])\\/([0-9]{2})$/,\n    message: {\n      required: 'Expiry date is required',\n      pattern: 'Please enter date in MM/YY format',\n      expired: 'Card has expired'\n    }\n  },\n  // Postal code validation\n  postalCode: {\n    required: false,\n    pattern: /^[0-9]{5}$/,\n    message: {\n      pattern: 'Postal code must be 5 digits'\n    }\n  },\n  // Location code validation\n  locationCode: {\n    required: false,\n    pattern: /^[A-Z0-9]{2,10}$/,\n    maxLength: 10,\n    message: {\n      pattern: 'Location code must contain only uppercase letters and numbers',\n      maxLength: 'Location code cannot exceed 10 characters'\n    }\n  }\n};\n\n// Validation functions\nexport const validateField = (value, rule) => {\n  const errors = [];\n\n  // Required validation\n  if (rule.required && (!value || value.toString().trim() === '')) {\n    errors.push(rule.message.required);\n    return errors;\n  }\n\n  // Skip other validations if value is empty and not required\n  if (!value || value.toString().trim() === '') {\n    return errors;\n  }\n  const stringValue = value.toString().trim();\n\n  // Length validations\n  if (rule.minLength && stringValue.length < rule.minLength) {\n    errors.push(rule.message.minLength);\n  }\n  if (rule.maxLength && stringValue.length > rule.maxLength) {\n    errors.push(rule.message.maxLength);\n  }\n\n  // Pattern validation\n  if (rule.pattern && !rule.pattern.test(stringValue)) {\n    errors.push(rule.message.pattern);\n  }\n\n  // Multiple pattern validations (for password)\n  if (rule.patterns) {\n    Object.keys(rule.patterns).forEach(key => {\n      if (!rule.patterns[key].test(stringValue)) {\n        errors.push(rule.message[key]);\n      }\n    });\n  }\n\n  // Numeric validations\n  if (rule.min !== undefined || rule.max !== undefined || rule.integer) {\n    const numValue = parseFloat(value);\n    if (isNaN(numValue)) {\n      errors.push(rule.message.number || 'Must be a valid number');\n    } else {\n      if (rule.min !== undefined && numValue < rule.min) {\n        errors.push(rule.message.min);\n      }\n      if (rule.max !== undefined && numValue > rule.max) {\n        errors.push(rule.message.max);\n      }\n      if (rule.integer && !Number.isInteger(numValue)) {\n        errors.push(rule.message.integer);\n      }\n    }\n  }\n\n  // Date validations\n  if (rule.futureOnly) {\n    const dateValue = new Date(value);\n    const today = new Date();\n    today.setHours(0, 0, 0, 0);\n    if (dateValue < today) {\n      errors.push(rule.message.futureOnly);\n    }\n  }\n  return errors;\n};\n\n// Validate multiple fields\nexport const validateForm = (formData, rules) => {\n  const errors = {};\n  Object.keys(rules).forEach(fieldName => {\n    const fieldErrors = validateField(formData[fieldName], rules[fieldName]);\n    if (fieldErrors.length > 0) {\n      errors[fieldName] = fieldErrors[0]; // Show first error only\n    }\n  });\n  return errors;\n};\n\n// Custom validation functions\nexport const validatePasswordMatch = (password, confirmPassword) => {\n  if (password !== confirmPassword) {\n    return 'Passwords do not match';\n  }\n  return null;\n};\nexport const validateLocationsDifferent = (origin, destination) => {\n  if (origin && destination && origin === destination) {\n    return 'Origin and destination must be different';\n  }\n  return null;\n};\nexport const validateDateRange = (startDate, endDate) => {\n  if (startDate && endDate) {\n    const start = new Date(startDate);\n    const end = new Date(endDate);\n    if (end <= start) {\n      return 'End date must be after start date';\n    }\n  }\n  return null;\n};\nexport const validateCardExpiry = expiryDate => {\n  if (!expiryDate) return null;\n  const match = expiryDate.match(/^(0[1-9]|1[0-2])\\/([0-9]{2})$/);\n  if (!match) return 'Please enter date in MM/YY format';\n  const month = parseInt(match[1], 10);\n  const year = parseInt('20' + match[2], 10);\n  const now = new Date();\n  const currentMonth = now.getMonth() + 1;\n  const currentYear = now.getFullYear();\n  if (year < currentYear || year === currentYear && month < currentMonth) {\n    return 'Card has expired';\n  }\n  return null;\n};\n\n// Format functions\nexport const formatCardNumber = value => {\n  const cleaned = value.replace(/\\s+/g, '').replace(/[^0-9]/gi, '');\n  const matches = cleaned.match(/\\d{4,16}/g);\n  const match = matches && matches[0] || '';\n  const parts = [];\n  for (let i = 0, len = match.length; i < len; i += 4) {\n    parts.push(match.substring(i, i + 4));\n  }\n  if (parts.length) {\n    return parts.join(' ');\n  } else {\n    return cleaned;\n  }\n};\nexport const formatExpiryDate = value => {\n  const cleaned = value.replace(/\\D/g, '');\n  const match = cleaned.match(/^(\\d{1,2})(\\d{0,2})$/);\n  if (match) {\n    const month = match[1];\n    const year = match[2];\n    if (month.length === 1 && parseInt(month) > 1) {\n      return '0' + month + (year ? '/' + year : '');\n    }\n    if (month.length === 2) {\n      const monthNum = parseInt(month);\n      if (monthNum > 12) {\n        return '12' + (year ? '/' + year : '');\n      }\n      return month + (year ? '/' + year : '');\n    }\n    return month;\n  }\n  return cleaned;\n};\nexport const formatPhoneNumber = value => {\n  const cleaned = value.replace(/\\D/g, '');\n  if (cleaned.startsWith('60')) {\n    return '+' + cleaned;\n  } else if (cleaned.startsWith('0')) {\n    return '+6' + cleaned;\n  } else if (cleaned.length >= 9) {\n    return '+60' + cleaned;\n  }\n  return value;\n};\n\n// Real-time validation hook\nexport const useValidation = (initialData = {}, validationRules = {}) => {\n  _s();\n  const [formData, setFormData] = useState(initialData);\n  const [errors, setErrors] = useState({});\n  const [touched, setTouched] = useState({});\n  const validateSingleField = (fieldName, value) => {\n    if (validationRules[fieldName]) {\n      const fieldErrors = validateField(value, validationRules[fieldName]);\n      return fieldErrors.length > 0 ? fieldErrors[0] : null;\n    }\n    return null;\n  };\n  const handleChange = (fieldName, value) => {\n    setFormData(prev => ({\n      ...prev,\n      [fieldName]: value\n    }));\n\n    // Clear error if field becomes valid\n    if (touched[fieldName]) {\n      const error = validateSingleField(fieldName, value);\n      setErrors(prev => ({\n        ...prev,\n        [fieldName]: error\n      }));\n    }\n  };\n  const handleBlur = fieldName => {\n    setTouched(prev => ({\n      ...prev,\n      [fieldName]: true\n    }));\n    const error = validateSingleField(fieldName, formData[fieldName]);\n    setErrors(prev => ({\n      ...prev,\n      [fieldName]: error\n    }));\n  };\n  const validateAll = () => {\n    const allErrors = validateForm(formData, validationRules);\n    setErrors(allErrors);\n    setTouched(Object.keys(validationRules).reduce((acc, key) => {\n      acc[key] = true;\n      return acc;\n    }, {}));\n    return Object.keys(allErrors).length === 0;\n  };\n  const resetForm = () => {\n    setFormData(initialData);\n    setErrors({});\n    setTouched({});\n  };\n  return {\n    formData,\n    errors,\n    touched,\n    handleChange,\n    handleBlur,\n    validateAll,\n    resetForm,\n    isValid: Object.keys(errors).length === 0\n  };\n};\n_s(useValidation, \"sT0rcEwRM4bkknb6qL4Zx2xiuos=\");","map":{"version":3,"names":["useState","ValidationRules","name","required","minLength","maxLength","pattern","message","email","phone","password","patterns","lowercase","uppercase","number","special","location","different","date","futureOnly","invalid","price","min","max","decimal","latitude","longitude","passengers","integer","cardNumber","cvv","expiryDate","expired","postalCode","locationCode","validateField","value","rule","errors","toString","trim","push","stringValue","length","test","Object","keys","forEach","key","undefined","numValue","parseFloat","isNaN","Number","isInteger","dateValue","Date","today","setHours","validateForm","formData","rules","fieldName","fieldErrors","validatePasswordMatch","confirmPassword","validateLocationsDifferent","origin","destination","validateDateRange","startDate","endDate","start","end","validateCardExpiry","match","month","parseInt","year","now","currentMonth","getMonth","currentYear","getFullYear","formatCardNumber","cleaned","replace","matches","parts","i","len","substring","join","formatExpiryDate","monthNum","formatPhoneNumber","startsWith","useValidation","initialData","validationRules","_s","setFormData","setErrors","touched","setTouched","validateSingleField","handleChange","prev","error","handleBlur","validateAll","allErrors","reduce","acc","resetForm","isValid"],"sources":["/Users/gohshunda/TWT-Transport-Booking/src/utils/validation.js"],"sourcesContent":["import { useState } from 'react';\n\n// Validation utility functions and rules\nexport const ValidationRules = {\n  // Name validation\n  name: {\n    required: true,\n    minLength: 2,\n    maxLength: 50,\n    pattern: /^[a-zA-Z\\s'-]+$/,\n    message: {\n      required: 'Name is required',\n      minLength: 'Name must be at least 2 characters',\n      maxLength: 'Name cannot exceed 50 characters',\n      pattern: 'Name can only contain letters, spaces, hyphens, and apostrophes'\n    }\n  },\n\n  // Email validation\n  email: {\n    required: true,\n    pattern: /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/,\n    maxLength: 320,\n    message: {\n      required: 'Email is required',\n      pattern: 'Please enter a valid email address',\n      maxLength: 'Email cannot exceed 320 characters'\n    }\n  },\n\n  // Phone validation (Malaysian format)\n  phone: {\n    required: false,\n    pattern: /^(\\+?6?01)[0-46-9]-*[0-9]{7,8}$/,\n    message: {\n      pattern: 'Please enter a valid Malaysian phone number (e.g., +60123456789)'\n    }\n  },\n\n  // Password validation\n  password: {\n    required: true,\n    minLength: 8,\n    maxLength: 128,\n    patterns: {\n      lowercase: /[a-z]/,\n      uppercase: /[A-Z]/,\n      number: /[0-9]/,\n      special: /[!@#$%^&*(),.?\":{}|<>]/\n    },\n    message: {\n      required: 'Password is required',\n      minLength: 'Password must be at least 8 characters',\n      maxLength: 'Password cannot exceed 128 characters',\n      lowercase: 'Password must contain at least one lowercase letter',\n      uppercase: 'Password must contain at least one uppercase letter',\n      number: 'Password must contain at least one number',\n      special: 'Password must contain at least one special character'\n    }\n  },\n\n  // Location validation\n  location: {\n    required: true,\n    message: {\n      required: 'Please select a location',\n      different: 'Origin and destination must be different'\n    }\n  },\n\n  // Date validation\n  date: {\n    required: true,\n    futureOnly: true,\n    message: {\n      required: 'Date is required',\n      futureOnly: 'Date must be in the future',\n      invalid: 'Please enter a valid date'\n    }\n  },\n\n  // Price validation\n  price: {\n    required: true,\n    min: 0,\n    max: 9999.99,\n    decimal: 2,\n    message: {\n      required: 'Price is required',\n      min: 'Price cannot be negative',\n      max: 'Price cannot exceed RM 9,999.99',\n      number: 'Price must be a valid number'\n    }\n  },\n\n  // Coordinates validation\n  latitude: {\n    required: false,\n    min: -90,\n    max: 90,\n    message: {\n      min: 'Latitude must be between -90 and 90',\n      max: 'Latitude must be between -90 and 90',\n      number: 'Latitude must be a valid number'\n    }\n  },\n\n  longitude: {\n    required: false,\n    min: -180,\n    max: 180,\n    message: {\n      min: 'Longitude must be between -180 and 180',\n      max: 'Longitude must be between -180 and 180',\n      number: 'Longitude must be a valid number'\n    }\n  },\n\n  // Passenger count validation\n  passengers: {\n    required: true,\n    min: 1,\n    max: 8,\n    integer: true,\n    message: {\n      required: 'Number of passengers is required',\n      min: 'At least 1 passenger is required',\n      max: 'Maximum 8 passengers allowed',\n      integer: 'Number of passengers must be a whole number'\n    }\n  },\n\n  // Card number validation\n  cardNumber: {\n    required: true,\n    pattern: /^[0-9]{13,19}$/,\n    message: {\n      required: 'Card number is required',\n      pattern: 'Please enter a valid card number (13-19 digits)'\n    }\n  },\n\n  // CVV validation\n  cvv: {\n    required: true,\n    pattern: /^[0-9]{3,4}$/,\n    message: {\n      required: 'CVV is required',\n      pattern: 'CVV must be 3 or 4 digits'\n    }\n  },\n\n  // Expiry date validation\n  expiryDate: {\n    required: true,\n    pattern: /^(0[1-9]|1[0-2])\\/([0-9]{2})$/,\n    message: {\n      required: 'Expiry date is required',\n      pattern: 'Please enter date in MM/YY format',\n      expired: 'Card has expired'\n    }\n  },\n\n  // Postal code validation\n  postalCode: {\n    required: false,\n    pattern: /^[0-9]{5}$/,\n    message: {\n      pattern: 'Postal code must be 5 digits'\n    }\n  },\n\n  // Location code validation\n  locationCode: {\n    required: false,\n    pattern: /^[A-Z0-9]{2,10}$/,\n    maxLength: 10,\n    message: {\n      pattern: 'Location code must contain only uppercase letters and numbers',\n      maxLength: 'Location code cannot exceed 10 characters'\n    }\n  }\n};\n\n// Validation functions\nexport const validateField = (value, rule) => {\n  const errors = [];\n\n  // Required validation\n  if (rule.required && (!value || value.toString().trim() === '')) {\n    errors.push(rule.message.required);\n    return errors;\n  }\n\n  // Skip other validations if value is empty and not required\n  if (!value || value.toString().trim() === '') {\n    return errors;\n  }\n\n  const stringValue = value.toString().trim();\n\n  // Length validations\n  if (rule.minLength && stringValue.length < rule.minLength) {\n    errors.push(rule.message.minLength);\n  }\n\n  if (rule.maxLength && stringValue.length > rule.maxLength) {\n    errors.push(rule.message.maxLength);\n  }\n\n  // Pattern validation\n  if (rule.pattern && !rule.pattern.test(stringValue)) {\n    errors.push(rule.message.pattern);\n  }\n\n  // Multiple pattern validations (for password)\n  if (rule.patterns) {\n    Object.keys(rule.patterns).forEach(key => {\n      if (!rule.patterns[key].test(stringValue)) {\n        errors.push(rule.message[key]);\n      }\n    });\n  }\n\n  // Numeric validations\n  if (rule.min !== undefined || rule.max !== undefined || rule.integer) {\n    const numValue = parseFloat(value);\n    \n    if (isNaN(numValue)) {\n      errors.push(rule.message.number || 'Must be a valid number');\n    } else {\n      if (rule.min !== undefined && numValue < rule.min) {\n        errors.push(rule.message.min);\n      }\n      \n      if (rule.max !== undefined && numValue > rule.max) {\n        errors.push(rule.message.max);\n      }\n      \n      if (rule.integer && !Number.isInteger(numValue)) {\n        errors.push(rule.message.integer);\n      }\n    }\n  }\n\n  // Date validations\n  if (rule.futureOnly) {\n    const dateValue = new Date(value);\n    const today = new Date();\n    today.setHours(0, 0, 0, 0);\n    \n    if (dateValue < today) {\n      errors.push(rule.message.futureOnly);\n    }\n  }\n\n  return errors;\n};\n\n// Validate multiple fields\nexport const validateForm = (formData, rules) => {\n  const errors = {};\n  \n  Object.keys(rules).forEach(fieldName => {\n    const fieldErrors = validateField(formData[fieldName], rules[fieldName]);\n    if (fieldErrors.length > 0) {\n      errors[fieldName] = fieldErrors[0]; // Show first error only\n    }\n  });\n  \n  return errors;\n};\n\n// Custom validation functions\nexport const validatePasswordMatch = (password, confirmPassword) => {\n  if (password !== confirmPassword) {\n    return 'Passwords do not match';\n  }\n  return null;\n};\n\nexport const validateLocationsDifferent = (origin, destination) => {\n  if (origin && destination && origin === destination) {\n    return 'Origin and destination must be different';\n  }\n  return null;\n};\n\nexport const validateDateRange = (startDate, endDate) => {\n  if (startDate && endDate) {\n    const start = new Date(startDate);\n    const end = new Date(endDate);\n    \n    if (end <= start) {\n      return 'End date must be after start date';\n    }\n  }\n  return null;\n};\n\nexport const validateCardExpiry = (expiryDate) => {\n  if (!expiryDate) return null;\n  \n  const match = expiryDate.match(/^(0[1-9]|1[0-2])\\/([0-9]{2})$/);\n  if (!match) return 'Please enter date in MM/YY format';\n  \n  const month = parseInt(match[1], 10);\n  const year = parseInt('20' + match[2], 10);\n  \n  const now = new Date();\n  const currentMonth = now.getMonth() + 1;\n  const currentYear = now.getFullYear();\n  \n  if (year < currentYear || (year === currentYear && month < currentMonth)) {\n    return 'Card has expired';\n  }\n  \n  return null;\n};\n\n// Format functions\nexport const formatCardNumber = (value) => {\n  const cleaned = value.replace(/\\s+/g, '').replace(/[^0-9]/gi, '');\n  const matches = cleaned.match(/\\d{4,16}/g);\n  const match = matches && matches[0] || '';\n  const parts = [];\n\n  for (let i = 0, len = match.length; i < len; i += 4) {\n    parts.push(match.substring(i, i + 4));\n  }\n\n  if (parts.length) {\n    return parts.join(' ');\n  } else {\n    return cleaned;\n  }\n};\n\nexport const formatExpiryDate = (value) => {\n  const cleaned = value.replace(/\\D/g, '');\n  const match = cleaned.match(/^(\\d{1,2})(\\d{0,2})$/);\n  \n  if (match) {\n    const month = match[1];\n    const year = match[2];\n    \n    if (month.length === 1 && parseInt(month) > 1) {\n      return '0' + month + (year ? '/' + year : '');\n    }\n    \n    if (month.length === 2) {\n      const monthNum = parseInt(month);\n      if (monthNum > 12) {\n        return '12' + (year ? '/' + year : '');\n      }\n      return month + (year ? '/' + year : '');\n    }\n    \n    return month;\n  }\n  \n  return cleaned;\n};\n\nexport const formatPhoneNumber = (value) => {\n  const cleaned = value.replace(/\\D/g, '');\n  \n  if (cleaned.startsWith('60')) {\n    return '+' + cleaned;\n  } else if (cleaned.startsWith('0')) {\n    return '+6' + cleaned;\n  } else if (cleaned.length >= 9) {\n    return '+60' + cleaned;\n  }\n  \n  return value;\n};\n\n// Real-time validation hook\nexport const useValidation = (initialData = {}, validationRules = {}) => {\n  const [formData, setFormData] = useState(initialData);\n  const [errors, setErrors] = useState({});\n  const [touched, setTouched] = useState({});\n\n  const validateSingleField = (fieldName, value) => {\n    if (validationRules[fieldName]) {\n      const fieldErrors = validateField(value, validationRules[fieldName]);\n      return fieldErrors.length > 0 ? fieldErrors[0] : null;\n    }\n    return null;\n  };\n\n  const handleChange = (fieldName, value) => {\n    setFormData(prev => ({\n      ...prev,\n      [fieldName]: value\n    }));\n\n    // Clear error if field becomes valid\n    if (touched[fieldName]) {\n      const error = validateSingleField(fieldName, value);\n      setErrors(prev => ({\n        ...prev,\n        [fieldName]: error\n      }));\n    }\n  };\n\n  const handleBlur = (fieldName) => {\n    setTouched(prev => ({\n      ...prev,\n      [fieldName]: true\n    }));\n\n    const error = validateSingleField(fieldName, formData[fieldName]);\n    setErrors(prev => ({\n      ...prev,\n      [fieldName]: error\n    }));\n  };\n\n  const validateAll = () => {\n    const allErrors = validateForm(formData, validationRules);\n    setErrors(allErrors);\n    setTouched(Object.keys(validationRules).reduce((acc, key) => {\n      acc[key] = true;\n      return acc;\n    }, {}));\n    \n    return Object.keys(allErrors).length === 0;\n  };\n\n  const resetForm = () => {\n    setFormData(initialData);\n    setErrors({});\n    setTouched({});\n  };\n\n  return {\n    formData,\n    errors,\n    touched,\n    handleChange,\n    handleBlur,\n    validateAll,\n    resetForm,\n    isValid: Object.keys(errors).length === 0\n  };\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}